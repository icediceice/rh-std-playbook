---
# AAP 2.5 Optimized OS Patching Playbook
# Compatible with Ansible Automation Platform 2.5 Web Console
# Survey file: patching_survey.json

- name: OS Patching Pre-flight Checks and Validation
  hosts: "{{ patch_target | default('all') }}"
  gather_facts: true
  gather_subset:
    - '!all'
    - 'min'
  serial: "{{ patching_batch_size | default('25%') }}"
  vars:
    # AAP 2.5 Survey Variables with Defaults and Validation
    patch_target: "{{ patch_target | default('all') }}"
    allow_reboot: "{{ allow_reboot | default('no') | bool }}"
    win_update_categories: "{{ win_update_categories_raw | default('SecurityUpdates\nCriticalUpdates') | splitlines }}"
    linux_exclude_packages: "{{ linux_exclude_packages | default('') }}"
    maintenance_window_hours: "{{ maintenance_window_hours | default(2) | int }}"
    pre_patch_snapshot: "{{ pre_patch_snapshot | default('no') | bool }}"
    notification_email: "{{ notification_email | default('') }}"
    
  tasks:
    - name: Create patching log directory
      ansible.builtin.file:
        path: /var/log/aap-patching
        state: directory
        mode: '0755'
      become: true
      when: ansible_os_family != "Windows"

    - name: Create Windows patching log directory
      ansible.windows.win_file:
        path: C:\AAP-Patching\Logs
        state: directory
      when: ansible_os_family == "Windows"

    - name: Set log file path variable
      ansible.builtin.set_fact:
        patching_log_file: "{{ '/var/log/aap-patching/patch-' + ansible_date_time.epoch + '.log' if ansible_os_family != 'Windows' else 'C:/AAP-Patching/Logs/patch-' + ansible_date_time.epoch + '.log' }}"

    - name: Set completion log file path variable
      ansible.builtin.set_fact:
        patching_complete_log_file: "{{ '/var/log/aap-patching/patch-complete-' + ansible_date_time.epoch + '.log' if ansible_os_family != 'Windows' else 'C:/AAP-Patching/Logs/patch-complete-' + ansible_date_time.epoch + '.log' }}"

    - name: Log patching start (append-only)
      ansible.builtin.blockinfile:
        path: "{{ patching_log_file }}"
        create: true
        marker: "# --- ANSIBLE PATCHING LOG - {mark} ---"
        block: |
          Patching Job Started: {{ ansible_date_time.iso8601 }}
          AAP Job ID: {{ awx_job_id | default('N/A') }}
          Target: {{ inventory_hostname }}
          OS Family: {{ ansible_os_family }}
          Allow Reboot: {{ allow_reboot }}
          Maintenance Window: {{ maintenance_window_hours }} hours
      become: "{{ ansible_os_family != 'Windows' }}"

    - name: Validate sufficient disk space
      ansible.builtin.assert:
        that:
          - item.size_available > 1073741824  # 1GB in bytes
        fail_msg: "Insufficient disk space on {{ item.mount }}: {{ (item.size_available/1024/1024/1024) | round(2) }}GB available"
      loop: "{{ ansible_facts.mounts }}"
      loop_control:
        label: "{{ item.mount }}"
      when: 
        - ansible_os_family != "Windows"
        - item.mount in ['/', '/var', '/tmp']

    - name: Validate sufficient disk space (Windows)
      ansible.windows.win_shell: |
        $drive = Get-PSDrive C
        if ($drive.Free -lt 1GB) {
          Write-Error "Insufficient disk space on C: drive: $($drive.Free / 1GB)GB available"
          exit 1
        }
        Write-Host "Disk space on C: is sufficient."
      register: win_disk_space
      changed_when: false
      when: ansible_os_family == "Windows"

    - name: Include Linux patching role
      ansible.builtin.include_role:
        name: linux_patching
      when: ansible_os_family in ["RedHat", "Debian"]

    - name: Include Windows patching role
      ansible.builtin.include_role:
        name: windows_patching
      when: ansible_os_family == "Windows"

- name: Post-Patching Reboot and Validation
  hosts: "{{ patch_target }}"
  gather_facts: false
  serial: "{{ patching_batch_size | default('25%') }}"
  vars:
    allow_reboot: "{{ allow_reboot | default('no') | bool }}"
    max_reboot_wait: "{{ max_reboot_wait | default(600) }}"

  tasks:
    - name: Check if reboot is required (Linux)
      ansible.builtin.stat:
        path: /var/run/reboot-required
      register: reboot_required_file
      when: ansible_os_family != "Windows"

    - name: Check if reboot is required (Windows)
      ansible.windows.win_shell: |
        if (Get-ChildItem "HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired" -ErrorAction SilentlyContinue) { 
          exit 1 
        } else { 
          exit 0 
        }
      register: windows_reboot_required
      failed_when: false
      when: ansible_os_family == "Windows"

    - name: Set reboot required fact
      ansible.builtin.set_fact:
        patching_reboot_required: "{{ 
          (reboot_required_file.stat.exists | default(false)) or 
          (windows_reboot_required.rc == 1) or
          (patching_reboot_required | default(false))  # Preserve fact from included role
        }}"

    - name: Notify about pending reboot
      ansible.builtin.debug:
        msg: "Reboot required for {{ inventory_hostname }} but automatic reboot is disabled"
      when: patching_reboot_required and not allow_reboot

    - name: Reboot system if required and allowed
      ansible.builtin.block:
        - name: Reboot Linux systems
          ansible.builtin.reboot:
            reboot_timeout: "{{ max_reboot_wait }}"
            connect_timeout: 5
            test_command: uptime
          become: true
          when: ansible_os_family != "Windows"

        - name: Reboot Windows systems
          ansible.windows.win_reboot:
            reboot_timeout: "{{ max_reboot_wait }}"
            connect_timeout: 5
          when: ansible_os_family == "Windows"

        - name: Wait for system to be accessible
          wait_for_connection:
            connect_timeout: 20
            sleep: 5
            delay: 5
            timeout: "{{ max_reboot_wait }}"

      when: patching_reboot_required and allow_reboot

    - name: Gather facts after potential reboot
      ansible.builtin.setup:
        filter:
          - ansible_kernel
          - ansible_uptime_seconds
      when: patching_reboot_required and allow_reboot

    - name: Log patching completion (append-only)
      ansible.builtin.blockinfile:
        path: "{{ patching_complete_log_file }}"
        create: true
        marker: "# --- ANSIBLE COMPLETION LOG - {mark} ---"
        block: |
          Patching Job Completed: {{ ansible_date_time.iso8601 }}
          AAP Job ID: {{ awx_job_id | default('N/A') }}
          Target: {{ inventory_hostname }}
          Reboot Required: {{ patching_reboot_required }}
          Reboot Performed: {{ allow_reboot and patching_reboot_required }}
          Current Kernel: {{ ansible_kernel | default('N/A') }}
          System Uptime: {{ ansible_uptime_seconds | default(0) }} seconds
      become: "{{ ansible_os_family != 'Windows' }}"

- name: Patching Summary and Notification
  hosts: localhost
  gather_facts: false
  connection: local
  become: false
  vars:
    patch_target: "{{ patch_target | default('all') }}"
    allow_reboot: "{{ allow_reboot | default('no') | bool }}"
    notification_email: "{{ notification_email | default('') }}"

  tasks:
    - name: Display job execution information
      ansible.builtin.debug:
        msg:
          - "=== AAP 2.5 OS Patching Job Information ==="
          - "Job Template: {{ awx_job_template_name | default('OS Patching') }}"
          - "Job ID: {{ awx_job_id | default('N/A') }}"
          - "Target Hosts: {{ patch_target }}"
          - "Allow Reboot: {{ allow_reboot }}"
          - "Started by: {{ awx_user_name | default(ansible_user_id) }}"
      tags: [always]

    - name: Validate maintenance window
      ansible.builtin.assert:
        that:
          - maintenance_window_hours | default(2) | int >= 1
          - maintenance_window_hours | default(2) | int <= 8
        fail_msg: "Maintenance window must be between 1-8 hours"
      vars:
        maintenance_window_hours: "{{ maintenance_window_hours }}"

    - name: Generate patching summary
      set_fact:
        patching_summary:
          job_id: "{{ awx_job_id | default('N/A') }}"
          started_by: "{{ awx_user_name | default(ansible_user_id) }}"
          target_hosts: "{{ groups[patch_target] if patch_target != 'all' else groups['all'] }}"
          total_hosts: "{{ (groups[patch_target] if patch_target != 'all' else groups['all']) | length }}"
          completion_time: "{{ ansible_date_time.iso8601 }}"
          reboot_allowed: "{{ allow_reboot }}"

    - name: Display patching summary
      ansible.builtin.debug:
        msg:
          - "=== AAP 2.5 Patching Job Summary ==="
          - "Job ID: {{ patching_summary.job_id }}"
          - "Started by: {{ patching_summary.started_by }}"
          - "Total Hosts Processed: {{ patching_summary.total_hosts }}"
          - "Completion Time: {{ patching_summary.completion_time }}"
          - "Reboot Policy: {{ 'Allowed' if patching_summary.reboot_allowed else 'Not Allowed' }}"
      tags: [always]

    - name: Send email notification
      community.general.mail:
        host: "{{ mail_smtp_host | default('localhost') }}"
        port: "{{ mail_smtp_port | default(25) }}"
        username: "{{ mail_smtp_user | default(omit) }}"
        password: "{{ mail_smtp_password | default(omit) }}"
        to: "{{ notification_email }}"
        subject: "AAP Patching Job {{ patching_summary.job_id }} - Completed"
        body: |
          Ansible Automation Platform Patching Job Summary
          
          Job ID: {{ patching_summary.job_id }}
          Started by: {{ patching_summary.started_by }}
          Target: {{ patch_target }}
          Total Hosts: {{ patching_summary.total_hosts }}
          Completion Time: {{ patching_summary.completion_time }}
          Reboot Policy: {{ 'Allowed' if patching_summary.reboot_allowed else 'Not Allowed' }}
          
          Please check the AAP web console for detailed logs and results.
      when: 
        - notification_email | default('') != ''
      delegate_to: localhost
      # Retry up to 3 times with a 15-second delay between attempts
      retries: 3
      delay: 15
      # Continue if the email fails after all retries
      ignore_errors: true